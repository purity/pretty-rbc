diff --git a/kernel/compiler/compile.rb b/kernel/compiler/compile.rb
index eb5d181..3fdb352 100644
--- a/kernel/compiler/compile.rb
+++ b/kernel/compiler/compile.rb
@@ -33,11 +33,13 @@ class Compiler
   end
 
   def self.compile_file(path, flags=nil)
-    compiler.compile_file(path, flags)
+    cm = compiler.compile_file(path, flags)
+    VerifyYieldDebugger.run(cm)
   end
 
   def self.compile_string(string, context=nil, filename="(eval)", line=1)
-    compiler.compile_string(string, context, filename, line)
+    cm = compiler.compile_string(string, context, filename, line)
+    VerifyYieldDebugger.run(cm)
   end
 
   def self.execute(string)
diff --git a/kernel/compiler/compiled_file.rb b/kernel/compiler/compiled_file.rb
index 43ce2a4..c2cbdf0 100644
--- a/kernel/compiler/compiled_file.rb
+++ b/kernel/compiler/compiled_file.rb
@@ -1,3 +1,39 @@
+
+class VerifyYieldDebugger
+
+  def self.all_methods(obj)
+    case obj
+    when CompiledMethod
+      cmethods = [obj]
+      obj.literals.each do |o|
+        cmethods += all_methods(o)
+      end
+      cmethods
+    else
+      []
+    end
+  end
+
+  def self.check(cm)
+    iseq = cm.iseq.decode
+
+    iseq.each_with_index do |obj, idx|
+      if idx % 2 == 0 and obj != [:yield_debugger]
+        raise "iseq doesn't have enough yield_debugger instructions #{iseq.inspect}"
+      end
+    end
+  end
+
+  def self.run(cm_main)
+
+    for cm in all_methods(cm_main)
+      check(cm)
+    end
+
+    cm_main
+  end
+end
+
 module Rubinius
   ##
   # A decode for the .rbc file format.
@@ -34,6 +70,7 @@ module Rubinius
     ##
     # Writes the CompiledFile +cm+ to +file+.
     def self.dump(cm, file)
+      VerifyYieldDebugger.run(cm)
       File.open(file, "w") do |f|
         new("!RBIX", 0, "x").encode_to(f, cm)
       end
diff --git a/kernel/compiler/generator.rb b/kernel/compiler/generator.rb
index 9e79d43..bf5b1b6 100644
--- a/kernel/compiler/generator.rb
+++ b/kernel/compiler/generator.rb
@@ -220,6 +220,9 @@ class Compiler
 
       return unless what
 
+      @ip += 1
+      @stream << :yield_debugger
+
       @ip += what.size
       if what.size == 1
         @stream << what.first
@@ -230,6 +233,10 @@ class Compiler
 
     def flush
       return unless @last
+
+      @ip += 1
+      @stream << :yield_debugger
+
       @ip += @last.size
       if @last.size == 1
         @stream << @last.first
diff --git a/vm/builtin/compiledmethod.cpp b/vm/builtin/compiledmethod.cpp
index 0009293..98c58a2 100644
--- a/vm/builtin/compiledmethod.cpp
+++ b/vm/builtin/compiledmethod.cpp
@@ -35,6 +35,7 @@ namespace rubinius {
     cm->local_count(state, Fixnum::from(0));
     cm->set_executor(CompiledMethod::default_executor);
     cm->backend_method_ = NULL;
+    cm->breakpoints = NULL;
 
     return cm;
   }
diff --git a/vm/builtin/compiledmethod.hpp b/vm/builtin/compiledmethod.hpp
index 4c9df31..bb41f52 100644
--- a/vm/builtin/compiledmethod.hpp
+++ b/vm/builtin/compiledmethod.hpp
@@ -37,7 +37,7 @@ namespace rubinius {
     /* accessors */
 
     VMMethod* backend_method_;
-
+    uint8_t* breakpoints;
 
     attr_accessor(name, Symbol);
     attr_accessor(iseq, InstructionSequence);
diff --git a/vm/helpers.cpp b/vm/helpers.cpp
index 81728de..ff8eb89 100644
--- a/vm/helpers.cpp
+++ b/vm/helpers.cpp
@@ -21,6 +21,7 @@
 #include "arguments.hpp"
 #include "call_frame.hpp"
 #include "lookup_data.hpp"
+#include "debugger.hpp"
 
 namespace rubinius {
   namespace Helpers {
@@ -271,26 +272,7 @@ namespace rubinius {
     }
 
     void yield_debugger(STATE, CallFrame* call_frame) {
-      Channel* chan;
-
-      state->set_call_frame(call_frame);
-
-      chan = try_as<Channel>(G(vm)->get_ivar(state,
-            state->symbol("@debug_channel")));
-
-      if(!chan) return;
-
-      Channel* control = state->thread->control_channel();
-
-      if(control->nil_p()) {
-        control = Channel::create(state);
-        state->thread->control_channel(state, control);
-      }
-
-      sassert(chan->has_readers_p());
-
-      chan->send(state, state->thread.get());
-      control->receive(state, call_frame);
+      state->shared.debug->run(state, call_frame);
     }
   }
 }
diff --git a/vm/vm.hpp b/vm/vm.hpp
index 92fb5dc..9a9b485 100644
--- a/vm/vm.hpp
+++ b/vm/vm.hpp
@@ -94,6 +94,7 @@ namespace rubinius {
   class VMManager;
   class Waiter;
   class SignalThread;
+  class Debugger;
 
   /* Indirect object handles for references to Ruby objects in
    * native code extensions.
@@ -120,6 +121,7 @@ namespace rubinius {
     Interrupts interrupts;
     SymbolTable symbols;
     ConfigParser *user_config;
+    Debugger* debug;
 
   public:
     SharedState(VMManager& manager, int id)
@@ -129,6 +131,7 @@ namespace rubinius {
       , om(0)
       , global_cache(0)
       , user_config(0)
+      , debug(NULL)
     {}
 
     ~SharedState();
diff --git a/vm/vm_manager.cpp b/vm/vm_manager.cpp
index 9ae7e6f..7aafac3 100644
--- a/vm/vm_manager.cpp
+++ b/vm/vm_manager.cpp
@@ -1,10 +1,12 @@
 #include "vm_manager.hpp"
 #include "vm.hpp"
+#include "debugger.hpp"
 
 namespace rubinius {
   SharedState* VMManager::create_shared_state() {
     SharedState* shared = new SharedState(*this, share_id_++);
     shares_[shared->id()] = shared;
+    shared->debug = new Debugger();
     return shared;
   }
 
